%!TEX root = ../head.tex

\chapter{Vorlesung}
\section{Einführung}

Gründe für DBS-Einsatz:
\begin{itemize}
\item Effizienz und Skalierbarkeit
\item Fehlerbehandlung und Fehlertoleranz
\item Mehrbenutzersynchronisation
\end{itemize}

ANSI - Database
\begin{itemize}
\item Standard siehe 1VL
\end{itemize}

Geschichte der Datenbanktechnologie
\begin{itemize}
\item siehe 1VL(28 ff.)
\end{itemize}


Databases vs Information Retrieval
\begin{itemize}
\item Information Retrieval 1VL(44)
\begin{itemize}
\item Suche nach Dokumenten
\item Nimmt ständig zu
\item In welchem Datenbstadn wird gesucht? etc...
\end{itemize}
\end{itemize}

Databases vs Big Data
\begin{itemize}
\item Big Data 1VL(47)
\end{itemize}

\section{Konzeptueller Entwurf}
\subsection{Drei Phasen des Datenbank-Entwurfs (4, ff.)}
\subsubsection{Phasen der SW-Entwicklung}
\begin{itemize}
	\item Anforderungs-analyse \(\to\) Vorstudie
	\item Fachentwurf \(\to\) Fachknozept
	\item IT-Entwurf \(\to\) IT-Konzept
	\item Implementierung \(\to\) Module/Klassen/DB-Tabellen
\end{itemize}
\subsubsection{Phasen des DB-Entwurfs}
\begin{itemize}
	\item nach Fachentwurf: fachliche Anforderungen an Datenstrukturen \(\to\) Konzeptueller DB-Entwurf \(\to\) Konzeptuelles Schema (ER-D, UML, etc.)
	\item nach IT-Entwurf: Entscheidung für logisches (Implementierungs-)Modell \(\to\) Logischer DB-Entwurf \(\to\) Logisches Schema (relational, OO, etc.)
	\item nach Implementierung: Umsetzung in konkeretem System \(\to\) Physischer DB-Entwurf \(\to\) Physisches Schema (konkretes DBS)
\end{itemize}
\begin{itemize}
	\item Datenbank = Schema + Daten
\end{itemize}
Datenbank = Schema + Daten
\subsection{Lebenszyklus einer Datenbank}
\begin{itemize}
\item Konzeptioneller Entwurf (12)
\item Logischer Entwurf (13)
\item Physischer Entwurf (14)
\item Wartung, Modifikationen, Erweiterungen (14)
\item Beispiel (15)
\end{itemize}
\subsection{Prinzip eines Datenmodells (16)}
\begin{itemize}
	\item Grundlegendes Prinzip
	\item Leistung: Beschreibung
	\item Bestandteile
	\item Skizze (17)
\end{itemize}
\subsection{Entity-Relationship-Modell}
\subsubsection{Entitäten (20)}
	\begin{itemize}
		\item Definition
		\begin{itemize}
			\item Existiert in der realen Welt, unterscheidet sich von anderen Entitäten
			\item Eine Entität ist ein Objekt der realen oder der Vorstellungswelt, über das Informationen gespeichert werden sollen
			\item Es ist im Sinne der Anwendung eindeutig berschreibbar und von anderen unterscheidbar
			\item Gleichartige Entitäten werden zu Entitätstypen (Entitätsmengen) zusammengefasst
		\end{itemize}
		\item Anmerkung
		\begin{itemize}
			\item Welche Entitäten zusammengehören, ist von Semantik der Anwendung abhängig
		\end{itemize}
		\item Merkmale von Entitätstypen (21)
		\begin{itemize}
			\item Nur für die Anwendung relevante Merkmale werden modelliert
			\item Beschreiben eine charakteristische Eigenschaft eines Eintitätstypes
			\item Werte eines Attributes aus Wertebereichen wie INTEGER, REAL, STRING
		\end{itemize}
		\item Schlüsselattribut(e)
		\begin{itemize}
			\item Ein Attribut oder eine Menge von Attributen, anhand deren Entitäten eines Entitätstyps unterscheiden lassen
			\item Werden durch Unterstreichung gekennzeichnet
			\item Beispiel: die ISBN-Nummer identifiziert das Buch
		\end{itemize}
		\end{itemize}
\subsubsection{Beziehungen / Relationships (22)}
	\begin{itemize}
		\item Abbildung von Zusammenhängen zwischen Entitäten
		\item Homogene Menge von Beziehungen wird zu Beziehungstyp zusammengefasst
		\item binär / n-när
		\item Kardinalitäten Titel \(\leftrightarrow\) Exemplar
		\item Bemerkungen
		\begin{itemize}
		\item Ein Entitätstyp darf in einem Beziehungstyp mehrfach vorkommen
		\item Mehr als zweistellige Beziehungstypen dürfen vorkommen
		\item Beziehungstypen können auch Attribute besitzen
		\end{itemize}
	\end{itemize}
\subsubsection{Beispiel eines ER-Diagramms (23)}
\subsubsection{Beispiel Funtkionalitäten (24)}
\subsubsection{Funktionalität von Beziehungstypen (25)}
	\begin{itemize}
		\item Beispiele (26 ff.)
	\end{itemize}
\subsubsection{Besonderheiten (32 ff.)}
	\begin{itemize}
		\item Rolle
		\begin{itemize}
			\item Anfrage an DB: "Gib mir alle Angestellten, die mehr verdienen als ihr Chef"
		\end{itemize}
		\item Extended-ER
		\begin{itemize}
			\item Weak Enitites
			\begin{itemize}
				\item ID nur im Kontext eindeutig (Bsp.: Stuhlnummer in Hörsaal 003 \(\leftrightarrow\) Stuhlnummer in Hörsaal 004)
			\end{itemize}
			\item Strukturierte Attribute
			\begin{itemize}
				\item Min-Max Beziehung (35 ff.)
			\end{itemize}
			
		\end{itemize}
	\end{itemize}
\subsubsection{Entwurf eines ER Diagramms (38 ff.)}
\subsubsection{Varianten für mehrstellige Beziehungstypen (40)}
\section{Konzeptueller Entwurf}
\subsection{Grundlagen (5)}
\subsubsection{Ausgangspunkt}
\begin{itemize}
	\item Idee und mathematische Formulierung geht zurück auf Ted Codd
	\item Basis für eine Vielzahl kommerzieller DBMS
\end{itemize}
\subsubsection{Grundlagen}
\begin{itemize}
	\item Domänen / Wertebereiche: Integer, Sing[20], Datum, ...
	\item Relation R ist definiert auf einem Relationenschema RS:
	\begin{itemize}
		\item RS: Menge von Attributen \(\{A_{1},\ldots,A_{k}\}\)
		\item Attribute: Wertebereiche \(D_{j} = \text{dom} (A_{j})\)
		\item Relation: Teilmenge des kartesischen Produkts der Wertebereiche \(R \subseteq D_{1}\times D_{2} \times \ldots \)
	\end{itemize}
	\item weitere Terminologie (6)
	\begin{itemize}
		\item Tupel: Element einer Relation
		\item Kardinalität einer Relation: Anzahl der Tupel in einer Relation (endlich!!)
		\item Darstellung der Relationen in Tabellenform
	\end{itemize}
	\item Relationenschema (7): (Name, Einwohner, land) mit dom(Name) = String[40], ...
	\item Ausprägungen
	\item Allgemein
\end{itemize}
\subsection{Primärschlüssel (8)}
	\begin{itemize}
		\item Eindeutigkeit \(\forall t_{i}, t_{i} \in R : t_{i}[x]=t_{j}[x] \Rightarrow i = j \)
		\item Minimalität \(\tau \exists Z \subset X(Z+X) \), so dass alle anderen Bedingungen gelten
		\item Definiertheit \(\forall t_{i} \in R : t[x] \ne \text{NULL}\)
	\end{itemize}
\subsection{ER-Modell Relationales Modell}
\subsubsection{Übersetzung von Entitäten}
Eins-zu-Eins Übersetzung in Relationen
\subsubsection{Übersetzung von Attributen}
\begin{itemize}
	\item Einfache Attribute
	\item Zusammengesetzte Attribute (z.B.: Adresse)
	\begin{itemize}
		\item Berechnete Attribute (z.B.: Umsatz = Preis * Verkauf)
		\item Mehrwertige Attribute (z.B.: Telefonnummer)
	\end{itemize}
\end{itemize}
\subsubsection{Übersetzung von Beziehungen}
\begin{itemize}
	\item Übersetzung von 1:1 Beziehungen (15)
	\begin{itemize}
		\item Fall 1
		\item Fall 2
		\item Fall 3
	\end{itemize}
	\item Übersetzung von 1:N Beziehungen (16)
	\begin{itemize}
		\item Fall 1
		\item Fall 2
	\end{itemize}
	\item Übersetzung von N:M Beziehungen (18)
	\item Übersetzung von Beziehungen zwischen mehr als zwei Relationen
	\item Übersetzung rekursiver Beziehungen (19)
	\item Übersetzung von Attributen an Beziehungen (20)
	\item Übersetzung von Vererbungsbeziehungen
\end{itemize}
\subsubsection{Abbildung der Vererbung 21}
\begin{itemize}
	\item Horizontale Partitionierung
	\item Vertikale Partitionierung
	\item Universalrelation (Typisierte Partitinierung)
\end{itemize}
\subsubsection{Vergleich der Abbildungsvarianten}
\begin{itemize}
	\item Jedes Objekt genau ein Tupel in genau einer Relation, d.h. gleiche ID bedeutet nicht: dasselbe Objekt
	\item Gesamtheit aller Attribute eines Objekts nur durch  Verbund zu ermitteln (teuer!)
	\item Referentielle Integrität unterstützt direkt Vererbung
\end{itemize}

\section{Relationale Algebra}
\subsection{Motivation}
\begin{itemize}
	\item Formale Sprache, mit der sich Anfragen über einem relationalen Schmea formulieren lsassen
	\item Formale Sprache für den Berechnungsweg von Anfrageergebnissen
	\item Internrepräsentation für DB-Anfragen
	\item Mathematische Rechenregeln ermöglichen Abfrageoptimierung durch algebraische Umformung
	\item Nicht für den Nutzer eines DBMS sichtbar
	\item Auch geeignet zur Formulierung von Integritätsbedingungen	
\end{itemize}
\subsection{Relationale Algebra}
\begin{itemize}
	\item Gegeben eine Menge N(Anker der Algebra): Menge der Relationen
	\item Operationen opj: \(N^k\to N\) (Abgeschlossenheit)
	\item 5 Basisoperationen
\end{itemize}
\subsection{Basisoperationen}
\subsubsection{Projektion}
\textbf{Definition } Sei A' eine Teilmenge der Attribute einer Relation \(R(A_1, ... A_n)\). Die Projektion de rAttribute A' aus einem Tupel \(t\in T\) ist definiert als das Tupel:
\begin{align*}
	\pi_{A'} = (A_1'(t), \ldots , A_m'(t))
\end{align*}
Die Projektion der Attribute A' einer Relation R ist definiert als die Relation
\begin{align*}
	\pi_{A'}(R) = \{\pi_{A'}(t)|t\in T\}
\end{align*}
heißt: Projektion ist eine Operation, die bestimmte Spalten aus einer Relation auswählt und diese als neue Relation ausgibt
\begin{itemize}
	\item Da Dubletten (identische Tupel) in Relationen nicht vorkommen drüfen, enthält die Projektion i.A. weniger Tupel als die ursprüngliche Relation!
	\item ACHTUNG: Das ist in SQL standardmäßig nicht so!
\end{itemize}
\subsubsection{Projektion in SQL}
Projektion: \(\pi_{\text{Name,Ort}}(Studenten)\)\\
SQL Duplikate werden nicht standardmäßig eliminiert
\begin{lstlisting}
SELECT Name, Ort
FROM Studenten
\end{lstlisting}
SQL mit Duplikat Eliminierung
\begin{lstlisting}
SELECT DISTINKT Name, Ort
FROM Studenten
\end{lstlisting}
\subsubsection{Selektion(Restriktion)}
\textbf{Definition} Die Selektion einer Relation R ist definiert als die Menge aller Tupel aus R, die der Selektionsbedingung P genügen:
\begin{align*}
\sigma_F(R) = \{t|t\in R\wedge P(t)\}
\end{align*}
P setzt sich zusammen aus:
\begin{itemize}
	\item Operanden: Konstanten oder Name eines Attributs
	\item Vergleichsoperatoren
	\item Boolesche Operatoren
\end{itemize}
\subsubsection{Selektion in SQL}
\(\sigma_{\text{Name = 'Schmidt'}}(Studenten)\)
\begin{lstlisting}
SELECT *
FROM Studenten
WHERE Name = 'Schmidt'
\end{lstlisting}
\(\pi_{\text{Name, Vorname, Ort}}(\sigma_{\text{Name = 'Schmidt'}}(Studenten))\)
\begin{lstlisting}
SELECT Name, Vorname, Ort
FROM Studenten
WHERE Name = 'Schmidt' 
\end{lstlisting}
\subsubsection{Weitere Basisoperationen (15)}
\begin{itemize}
	\item Vereinigung \(R\cup S\)
	\item Differenz \(R - S\)
	\item Zusätzlicher Operator: Umbenennen von Relationen und Attributen: \(p_S(R)\)
\end{itemize}
\subsubsection{Beispiele für Anfragen (18)}
\subsection{Abgeleitete Operationen}
\subsubsection{Durchschnitt und Division}
\begin{itemize}
	\item Durchschnitt: \\
	\(R\cap S) := \{r|r\in R \text{ und } r \in S\}\) \\
	Es gilt: \(R\cap S = R - (R-S)\)
	\item Division: \\
	\(R \div S = \pi_{A-B}(R) - \pi_{A-B}((\pi_{A-B}(R) \times S)-R)\) 
\end{itemize}
\subsubsection{Natürlicher Verbund}
Natural Join: \(\bowtie\)
\begin{itemize}
	\item Wichtigste Operation neben der Selektion
	\item \textbf{Definition} \(R\bowtie S = \pi_{i_{k+1},\ldots, i_{r+s}}(\sigma_{R.A1 = S.B1 \wedge \ldots \wedge R.Ak = S.Bk}(R\times S))\)
\end{itemize}
\subsubsection{Theta- und Equi-Join}
\begin{itemize}
	\item Theta-Join: \(R \bowtie_\theta S\)\\
	\textbf{Definition} \(R\bowtie_{i\theta j}S = \sigma_{A_i\theta B_j}(R\times S)\) mit \(\theta \in \{=, \ne, <, \le, >, \ge \}\)
	\item Equi-Join: Theta Join mit \(\theta\) gleich '='
\end{itemize}
\subsubsection{Verlustfreiheit von Joins}
\textbf{Definition} Eine Join-Operation zwischen R und S heißt verlustfrei, wenn jeder Datensatz aus R und jeder Datensatz aus S in der Ergebnisrelation enthalten ist.
\begin{itemize}
	\item Die inverse Operation Projektion erzeugt dann wieder R und S aus dem Join-Ergebnis
	\item Tupel, denen bei Join-Operationen die entsprechenden Tupel in der anderen Tabelle fehlen, mit denen sie verknüpft werden können heißen auch 'Dangling Tupel' bzw. Datensätze
	\item Um sie in die Ergebnismenge mit aufnehmen zu können, werden die Outer-Join-Operatoren benötigt
	\item Inner Joins sind in der Regel verlustbehaftet!
\end{itemize}
\subsubsection{Outer Joins}
\begin{itemize}
	\item Left Outer Join: R {\tiny \textifsym{d|><|}} S
	\item Right Outer Join: R {\tiny \textifsym{|><|d}} S
	\item Full Outer Join: R {\tiny \textifsym{d|><|d}} S
\end{itemize}