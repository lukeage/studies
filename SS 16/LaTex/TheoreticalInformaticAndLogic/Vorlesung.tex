%!TEX root = ../../head.tex

\chapter{Vorlesung \cite[S. 22]{Hoelldobler2011}}
\section{Prädikatenlogik erster Stufe}
\begin{itemize}
\item Syntax
\begin{itemize}
	\item Ein Alphabet der Prädikatenlogik besteht aus ... (2)
	\item forall heist universeller Quantor, exists heißt							existenzieller Quantor
	\item Funktions- und Relationssymbolen ist eine Stelligkeit n el N			\item Nullstellige Funktionssymbole werden als ... (3)
\end{itemize}
\item Terme
\begin{itemize}
	\item Definition 4.2 prädikatenlogische Terme (4)
	\item Ein Term ist abgeschlossen oder grundinstanziiert, wenn in ihm 			keine Variablen vorkommen
	\item Die Menge der abgeschlossenen Terme wird mit \textit{T}						(\textit{F}) bezeichnet
\end{itemize}
\item Prädikatenlogische Atome (5)
\item Prädikatenlogische Formeln (6)
\begin{itemize}
	\item prädikatenlogische Formeln
\end{itemize}
\item Strukturelle Rekursion 
\begin{itemize}
	\item Rekursionssätze lassen sich für \textit{T}(\textit{F},					\textit{V}) und \textit{L}(\textit{R},\textit{F},\textit{V}) 				formulieren 
	\item Es gibt genau eine Funktion \textit{foo} die die folgenden Bedingungen 				erfüllt: (7)
	\begin{itemize}
		\item Rekursionsanfang
		\item Rekursionsschritt
	\end{itemize}
	\item Beispiele (8/9)
\end{itemize}
\end{itemize}

\section{Prädikatenlogik erster Stufe}
\begin{itemize}
	\item Strukturelle Induktion
	\begin{itemize}
		\item Induktionssätze lassen sich für T(F,V) und L(R,F,V) 						formulieren
		\item jeder Term besitzt die Eigenschaft E, wenn: (10)
		\item analog für prädikatenlogische Formeln
	\end{itemize}
	\item Aufgabe (11)
	\begin{itemize}
		\item Beweisen Sie, dass \begin{math}\forall F \in L(R,F,V) 			\end{math} die Aussage \begin{math} l'(m(F))\ge l(F) \end{math} gilt 
	\end{itemize}
	\item Teilterme und Teilformeln (12)
	\begin{itemize}
		\item Die Def. 3.8 lässt sich auf Terme und Formeln übertragen
		\item Beispiel
	\end{itemize}
	\item Freie und gebundene Vorkommen einer Variablen (13)
	\begin{itemize}
		\item Def. 4.5 Die \textbf{freien Vorkommen einer Variablen} in 				einer prädikatenlogischen Formel sind wie folgt definiert: 					(13)
	\end{itemize}
	\item Abgeschlossene Terme und Formeln (14)
	\begin{itemize}
		\item nach Def. 4.2: Ein abgeschlossener Term ist ein Term, in 						dem	keine Variable vorkommt
		\item Def. 4.6 Eine abgeschlossene Formel (oder kurz 							ein Satz) der Sprache  \textit{L(R,F,V)} ist eine Formel der 			Sprache \textit{L(R,F,V)}, in der jedes Vorkommen einer 					Variablen gebunden ist
	\end{itemize}
	\item Substitutionen (19)
	\begin{itemize}
		\item Def. 4.7: Eine \textbf{Substitution} ist eine Abbildung 					\begin{math} \sigma : V \to T(F,V)\end{math}, die bis auf 					endlich viele Stellen mit der Identitätsabbildung 							übereinstimmt
		\item Beispiel
	\end{itemize}
	\item Instanzen
	\begin{itemize}
		\item Statt \begin{math} \sigma(X) \end{math} schreiben wirn in 				der Folge \begin{math} X\sigma \end{math}
		\item Def. 4.8: Sei sigma eine Substitution \begin{math} \sigma 				: V \to T(F,V)\end{math} kann wie folgt zu einer Abbildung 					\begin{math} \sigma dach: T(F,V) \to T(F,V)\end{math} 						erweitert werden: (25)
		\item Grundinstanz
		\item Proposition
	\end{itemize}
	\item Komposition von Substitutionen
	\begin{itemize}
		\item Def. 4.10: Seien \(\sigma\) und \(\theta\) zwei 							Substitutionen Die 	Komposition \(\sigma\theta\) von 						\(\sigma\) und \(\theta\) ist die Substitution: (30)
		\item Aufgaben
	\end{itemize}
\end{itemize}

\section{Syntax/Substitutionen}
\subsection{Komposition von Substitutionen}
\subsubsection{Korollar 4.11}
Für jede Substitution \(\sigma\) gilt \(\epsilon\sigma = \sigma = \sigma\epsilon \)
\subsubsection{Proposition 4.12}
Seien \(\sigma\) und \(\theta\) Substitutionen. Für jeden term t gilt \(t(\hat{\sigma\theta}) = (t\hat{\sigma})\theta \) \\ Beweis Strukturelle Induktion über t \(\to\) Übung
\subsubsection{Proposition 4.13}
Sei \(t \in T(F,V) \) und seien \(\sigma, \theta    \text{ sowie } \lambda \) Substitutionen. Dann gilt:
\begin{itemize}
	\item \( t (\hat{(\sigma\theta)\lambda})\)
	\item \(\sigma\theta)\lambda = \sigma(\theta\lambda)\)
\end{itemize}
Beweis siehe Folien (19)
\subsection{Beschränkung von Substitutionen}
\subsubsection{Definition 4.14}
Sei \(\sigma\) eine Substitution. Dann ist 
\begin{displaymath}
	\sigma_{x} = \begin{cases} \sigma &\text{wenn } X \notin \text{dom}( \sigma ) \\
\sigma / \{ X \mapsto t \} &\text{wenn } X \mapsto t \in\sigma
\end{cases}
\end{displaymath}
\subsubsection{Proposition 4.15}
Sei \(\sigma\) eine Substitution und t ein Term, in dem die Variable X nicht vorkommt.\\ Dann gilt: \(t\sigma = t\sigma_{X} \)
\subsection{Anwendung von Substitutionen auf Formeln}
\subsubsection{Definition 4.16}
Die Anwendung einer Substitution \(\sigma\) auf eine Formel ist induktiv über den Aufbau prädikatenlogische Formel wie folgt definiert:
\begin{itemize}
	\item \( p(t_{1} , \ldots , t_{n} ) \sigma = p(t_{1}\sigma , \ldots , t_{n}\sigma ) \)
	\item \((\neg F)\sigma = \neg (F\sigma) \)
	\item \((F\circ G)\sigma = (F\sigma \circ G\sigma)\) für jeden binären Junktor \(\circ\)
	\item \(((QX)F)\sigma = (QX)(F\sigma_{X})\) für jeden Quantor \(Q\)
\end{itemize}
\subsubsection{Beobachtung}
Bei der Anwendung einer Substitution auf eine Formel werden nur frei vorkommende Variablen ersetzt\\
Beweis: Übung
\subsection{Substitutionen und Formeln}
\subsubsection{Definition 4.17}
Eine Substitution \(\sigma\) ist genau dann frei für eine prädikatenlogische Formel F, wenn sie sich gemäß der folgenden bedingungen als frei erweist:
\begin{itemize}
	\item \(\sigma\) ist frei für \(F\), wenn \(F\) ein Atom ist
	\item \(\sigma\) ist frei für \(\neg F\) \textbf{gdw} \(\sigma\) ist frei für \(F\)
	\item \(\sigma\) ist frei für \((F\circ G)\) \textbf{gdw} \(\sigma\) ist frei für \(F\) und \(\sigma\) ist frei für \(G\)
	\item \(\sigma\) ist frei für \((QY)F\) \textbf{gdw} \(\sigma_{Y}\) ist frei für \(F\) und für jede von \(Y\) verschiedene und in \(F\) frei vorkommende Variable \(X\) gilt: \(Y\) kommt in \(X\sigma\) nicht vor 
\end{itemize}
\subsection{Satz 4.18}
\subsubsection{Satz 4.18}
Wenn die Substitution \(\sigma\) frei für die prädikatenlogische Formel \(F\) und die Substitution \(\theta\) frei für \(F\sigma\) ist, dann gilt: \(F(\sigma\theta) = (F\sigma)\theta \)
\subsubsection{Beweis Satz 4.18}
Strukturelle Induktion über \(F\)
\begin{itemize}
	\item[IA] \(F\) ist Atom der Form \(p(t_{1} , \ldots , t_{n})\)
	\begin{align*}
		&p(t_{1} , \ldots , t_{n} )(\sigma\theta)\\&=p(t_{1}(\sigma\theta) , \ldots , t_{n}(\sigma\theta)) &&\text{Def 4.16}\\ &= p((t_{1}\sigma)\theta , \ldots , (t_{n}\sigma)\theta) &&\text{Prop 4.12}\\ &= p(t_{1}\sigma, \ldots , t_{n}\sigma)\theta &&\text{Def 4.16}\\ &= p(t_{1}, \ldots , t_{n})\sigma)\theta &&\text{Def 4.16}
	\end{align*}
	\item[IH] Das Resultat gilt für \(F\)
	\item[IS]
	\begin{itemize}
		\item \textbf{Fall} \(\neg F\)
		\begin{align*}
		&\text{Sei } \sigma \text{ frei für } \neg F \text{ und } \theta \text{ frei für } (\neg F)\sigma \\ &\text{Da } \sigma \text{ frei für } \neg F \text{ ist, ist } \sigma \text{ auch frei für } F \\ &\text{Da } \theta \text{ frei für} (\neg F)\sigma \text{ und } (\neg F)\sigma = \neg (F\sigma) \text{ ist, ist } \theta \text{ auch frei für } F\sigma \\ &((\neg F)\sigma)\theta = (\neg(F\sigma))\theta = \neg ((F\sigma)\theta) =_{(IH)} \neg (F(\sigma\theta)) = (\neg F)\sigma\theta
		\end{align*}
		\item \textbf{Fall} \((F\circ G) \rightsquigarrow \) Übung
		\item \textbf{Fall} \((\forall X)F\)
		\begin{align*}
		&\text{Sei }\sigma \text{ frei für } (\forall X)F \text{ und } \theta \text{ frei für }((\forall X)F)\sigma \\ &\text{Da }\sigma \text{ frei für } (\forall X)F \text{ ist, ist }\sigma_{X} \text{ frei für } F \\&\text{Da }\theta \text{ frei für } ((\forall X)F)\sigma = (\forall X)(F\sigma_{X}) \text{ ist, ist } \theta_{X} \text{ frei für } F\sigma_{X} \\& \textbf{Hilfsaussage } F(\sigma_{X}\theta_{X}) = F(\sigma\theta)_{X} \\&\text{Dann gilt: }
		\end{align*}
		\begin{align*}
		&(((\forall X)F)\sigma)\theta\\&=((\forall X)(F\sigma_{X}))\theta &&\text{Def 4.16} \\&=(\forall X)((F\sigma_{X})\theta_{X}) &&\text{Def 4.16} \\&=(\forall X)(F(\sigma_{X}\theta_{X})) &&\text{IH} \\&=(\forall X)(F(\sigma\theta)_{X})&&\text{Hilfsaussage} \\& = ((\forall X)F)(\sigma\theta) &&\text{Def 4.16}
		\end{align*}
		\item \textbf{Fall} \(\exists X)F \rightsquigarrow\) Übung
	\end{itemize}
\end{itemize}

\subsection{Beweis Hilfsaussage aus Satz 4.18}
Unter den genannten Bedingungen gilt \(F(\sigma_{X}\theta_{X}) = F(\sigma\theta)_{X} \)\\ \textbf{Beweis} Da in \(F\) nur frei vorkommende Variablen ersetzt werden, genügt es zu zeigen, dass für jede frei in \(F\) vorkommende Variable \(Y\) gilt: \(Y(\sigma_{X}\theta_{X}) = Y(\sigma\theta)_{X} \)
\begin{itemize}
	\item \textbf{Fall} \(Y = X\)
	\begin{align*}
		&Y(\sigma_{X}\theta_{X}) = Y = Y(\sigma\theta)_{X}
	\end{align*}
	\item \textbf{Fall} \(Y \ne X\)
	\begin{align*}
	&Y\sigma = Y\sigma_{X} \text{ und } Y(\sigma\theta) = Y(\sigma\theta)_{X}\\&\text{Da }\sigma \text{ frei für } (\forall X)F \text{ ist, kommt die Variable } X \text{ in } Y\sigma \text{ nicht vor}\\&\text{Deshalb ist } (Y\sigma)\theta = (Y\sigma)\theta_{X} \\&\text{Dann gilt:}
	\end{align*}
	\begin{align*}
	&Y(\sigma_{X}\theta_{X})\\&=(Y\sigma_{X})\theta_{X} &&\text{Prop 4.12}\\&=(Y\sigma)\theta_{X} && (X \ne Y)\\&=(Y\sigma)\theta && X \text{ kommt in } Y \text{ nicht vor}\\&= Y(\sigma\theta) &&\text{Prop 4.12}\\&= Y(\sigma\theta)_{X} && (X \ne Y)\\&
	\end{align*}
\end{itemize}

\subsection{Varianten}
\subsubsection{Definition 4.19}
Seien \(E_{1} \) und \(E_{2} \) zwei Terme oder zwei prädikatenlogische Formeln. \(E_{1}\) und \(E_{2}\) heißen Varianten, wenn es Substitutionen \(\sigma \) und \(\theta \) gibt, so dass \(E_{1} = E_{2}\sigma \) und \(E_{2} = E_{1}\theta \). In diesem Fall wollen wir \(E_{1}\) auch als Variante von \(E_{2}\) und \(E_{2}\) als Variante von \(E_{1}\) bezeichnen. \\
Wenn \(E_{1}\) und \(E_{2}\) Varianten sind und die in \(E_{2}\) vorkommenden Variablen im bisherigen Kontext nicht verwendet wurden, dann ist \(E_{2}\) eine neue Variante von \(E_{1}\).

\section{Semantik}
\subsection{Relationen und Funktionen}
\begin{itemize}
	\item Sei D eine Menge ...
	\item Relationen ... 
	\item \textbf{Notation}: Anstelle von \((d)\) schreibt man häufig kurz \(d\)
	\item Funtionen (\(+,\circ,\))
\end{itemize}
\subsection{Interpretationen}
\subsubsection{Definition 4.20}
Eine prädikatenlogische Interpretation \(I\) für eine prädikatenlogische Sprache \(L(R,F,V)\) besteht aus einer nichtleeren Menge \(D\) und einer Abbildung \(\cdot ^I, \) die die folgenden Bedingungen erfüllt:
\begin{itemize}
	\item Jedem n-stelligen Funktionssymbol \(g\in F\) wird eine n-stellige Funktion \(g^I:D^n\to D\) zugeordnet
	\item Jedem n-stelligen Prädikatssymbol \(p\in R\) wird eine n-stellige Relation \(p^I \subseteq D^n\) zugeordnet
\end{itemize}
\(D\) wird Grundbereich oder auch Domäne der Interpretation genannt
\subsubsection{Definition 4.21}
Eine Variablenzuordnung bezüglich einer Interpretation \(I=(D,\cdot ^I)\) ist eine Abbildung \(Z: V\to D\) Das Bild einer Variablen \(X\) unter \(Z\) bezeichnen wir mit \(X^Z\) Sei \(Z\) eine Variablenzuordnung und \(d\in D\),  mit \(\{X \to d\}Z\) bezeichnen wir die Variablenzuordnung für die gilt:
\begin{displaymath}
	Y^{\{ X\mapsto d\}Z}  = \begin{cases}
		d &\text{wenn } Y = X \\
		Y^Z &\text{sonst }
		\end{cases}
\end{displaymath}
\subsubsection{Definition 4.22}
Sei \(I=(D,\cdot ^I)\) eine Interpretation und \(Z\) eine Variablenzuordnung bezüglich \(I\). Die Bedeutung \(t^{I,Z}\) eines Terms \(t\in T(F,V)\) ist wie folgt definiert:
\begin{itemize}
	\item Für jede Variable \(X\in V: X^{I,Z} = X^Z\)
	\item Für jeden Term der Form \(g(t_{1}, \ldots, t_{n})\) ist
	\begin{displaymath}
		[g(t_{1}, \ldots, t_{n})]^{I,Z}=g^I(t_{1}^{I,Z},\ldots,t_n^{I,Z})
	\end{displaymath}
	wobei \(g/n\in F\) ist und \(t_1, \ldots, t_n \in T(F,V)\) sind
\end{itemize}
\subsubsection{Definition 4.23}
Sei \(I=(D,\cdot ^I)\) eine Interpretation und \(Z\) eine Variablenzuordnung bezüglich \(I\) und \(I\) und \(Z\) weisen jeder Formel \(F\in L(R,F,V)\) einen Wahrheitswert \(F^{I,Z} \) wie folgt zu: 
\begin{align*}
&[p(t_1,\ldots ,t_n)]^{I,Z} =  \top \text{ gdw } (t_1^{I,Z},\ldots ,t_n^{I,Z} \in p^I \\ &[\neg F )]^{I,Z} = \neg^*(F^{I,Z}) \\
&[(F\circ G)]^{I,Z} = (F^{I,Z}\circ^* G^{I,Z}) \text{ für alle binären Juntkoren }\circ \\
&[(\forall X)F]^{I,Z}=\top \text{ gdw } F^{I,\{X \mapsto d\}Z} = \top \text{ für alle } d \in D \\
&[(\exists X)F]^{I,Z}=\top \text{ gdw } F^{I,\{X \mapsto d\}Z} = \top \text{ für alle } d \in D \\
\end{align*}
\subsubsection{Proposition 4.24}
Wenn \(F\in L(R,F,V)\) abgeschlossen ist, dann gilt \(F^{I,Z} = F^{I,Z^I}\) für jede Interpretation \(I\) und alle Variablenzuordnungen \(Z\) und \(Z^I\) bezüglich \(I\)
\subsubsection{Lemma 4.25}
Seien \(s,t\) Terme, \(G\) eine Formel, \(Y\) eine Variable, \(I=(D,\cdot ^I)\) eine Interpretation, \(Z\) eine Variablenzuordnung bzgl. \(I\) und \(d\in D\). Wenn \([t]^{I,Z}= d\) ist, dann gilt:
\begin{align*}
&[s\{Y\mapsto t\}]^{I,Z}=[s]^{I,\{Y\mapsto d\} Z} \\
&[G\{Y\mapsto t\}]^{I,Z}=[G]^{I,\{Y\mapsto d\} Z}\text{, wenn } \{Y\mapsto t\} \text{ frei für } g \text{ ist }
\end{align*}
\\\textbf{Beweis} Induktion über den Aufbau von \(s\) bzw. \(G\) \(\rightsquigarrow\) Übung
\subsection{Herbrand-Interpretationen}
Im Folgenden nehmen wir an, dass \(F\) mindestens ein Konstantensymbol enthält. Ist das nicht der Fall, dann fügern wir zu \(F\) ein Symbol \(a/0\) hinzu
\subsubsection{Definition 4.26}
Sei \(F\) eine Menge von Funktionssymbolen, in der mindstens ein Konstantensymbol vorkommt. Eine Interpretation \(I=(D,\cdot ^I)\) für eine prädikatenlogische Sprache \(L(R,F,V)\) ist eine Herbrand-Interpretation, wenn die folgenden Bedingungen erfüllt sind:
\begin{align*}
	&D = T(F) \text{ (D wird Herbrand-Universum genannt})\\
	&\text{Für jeden abgeschlossenen Term } t\in T(F) \text{ gilt } t^I = t
\end{align*}
\section{Modelle}
\subsubsection{Herbrand-Interpretationen und Formeln (41)}
\subsubsection{Aufgabe (42)}
\subsection{Modelle für abgeschlossene Formeln}
\subsubsection{Definition 4.27}
Sei \(I = (D,\cdot ^I)\) eine Interpretation und \(F\in L(R,F,V)\) ein Satz \(I\) ist ein Modell für \(F\), symbolisch \(I \vDash F\), wenn gilt: \(F^I = \top \) \\
Viele aus der Aussagenlogik bekannte Begriffe und REsultate lassen sich auf die Prädikatenlogik übertragen. Zum Beispiel:
\begin{itemize}
	\item Allgemeingültigkeit, Erfüllbarkeit, Widerlegbarkeit und Unerfüllbarkeit
	\item z.B.: Ein Satz \(F\) ist allgemeingültig gdw alle Interpretationen Modelle für \(F\) sind
	\item Satz 3.14 erweitert: Ein Satz \(F\) ist allgemeingültig gdw  \(\neg F\) ist unerfüllbar
	\item Satz 3.17 erweitert: Seien \(F,F_{1}, \ldots, F_{n}\) Sätze\\ \(\{F_{1}, \ldots , F_{n}\} \vDash F\) gdw \(\vDash (\langle F_{1}, \ldots, F_{n} \rangle \to F)\)
\end{itemize}
\subsubsection{Definition 4.28}
Ein Satz F ist eine (prädikatenlogische) Konsequenz der Menge \(G\) von Sätzen, symbolisch \\ \(G \vDash F\), gdw. jedes Modell für alle Elemente aus \(G\) auch Modell für \(F\) ist.
\subsubsection{Aufgaben (45)}
\subsubsection{Aussagenlogik - Prädikatenlogik}
\begin{itemize}
	\item Wenn alle Relationssymbole in \(R\) nullstellig sind, dann ist die Prädikatenlogik äquivalent zur Aussagenlogik
	\item Wenn in der Formeln keine Variablen vorkommen, dann ist die Prädikatenlogik äquivalent zur Aussagenlogik
\end{itemize}
\subsection{Modelle für nicht-abgeschlossene Formeln}
\subsubsection{Definition 4.29}
Sei \(G \in L(R,F,V) \) und \(fv(G) = \{X_{1}, \ldots , X_{n}\}\)
\begin{align*}
& ucl(G) = (\forall (X_{1}, \ldots , X_{n}) G \text{ ist der universelle Abschluss von } G \\
& ecl(G) = (\exists X_{1}, \ldots , X_{n}) G \text{ ist der existenzielle Abschluss von } G
\end{align*}
\subsubsection{Definition 4.30}
\begin{align*}
& I \vDash _{u} \text{ wenn } I \vDash ucl(G) \\
& I \vDash _{e} \text{ wenn } I \vDash ecl(G) 
\end{align*}
\subsubsection{Proposition 4.31}
Für alle Sätze G gilt:
\begin{align*}
& ucl(G) = G = ecl (G) \\
& I \vDash G \text{ gdw } I \vDash _{u} G \text{ gdw } I \vDash_{e} G
\end{align*}
\subsubsection{Universeller Abschluss: Einige Eigenschaften (49)}
\begin{align*}
&\vDash _{u} ((\forall X)p(X) \to p(X)) \\
&\nvDash _{u} (p(X) \to (\forall X)p(X) 
\end{align*}

\section{Äquivalenz und Normalform}
\subsection{Semantische Äquivalenz}
\subsubsection{Definition}
Zwei prädikatenlogische Formeln \(F\) und \(G\) heißen \textbf{semantisch äquivalent}, symbolisch \(F\equiv G\), wenn \(F^{I,Z} = G^{I,Z}\) für alle Interpretationen \(I\) und alle Variablenzuweisungen \(Z\) bezüglich \(I\)
\subsubsection{Satz 3.19}
Für prädikatenlogische Sätze, Formeln gilt:
\begin{align*}
F \equiv G \leftrightarrow F^I = G^I
\end{align*}
\subsubsection{Satz 4.32}
Seien F und G prädikatenlogische Formeln. Dann gilt:
\begin{align*}
\neg(\forall X)F&\equiv (\exists X)\neg F \\
\neg(\exists X)F &\equiv (\forall X)\neg F \\
((\forall X) F \wedge (\forall X)G) &\equiv (\forall X)(F\wedge G)\\
\\
&fill
\end{align*}
\subsubsection{Beweis 1}
siehe Script, die anderen in Eigenarbeit
\subsubsection{Definition 4.33}
Die in einer Prädikatenlogischen Formel \(F\) vorkommenden Variablen sind \textbf{auseinander dividiert}, wenn keine zwei in \(F\) vorkommenden Quantoren die gleiche Variable binden und keine Variable sowohl frei als auch gebunden vorkommt
\subsubsection{Definition 4.33}
Zu jeder prädikatenlogischen Formel gibt es eine semantisch äquivalente Formel, in der die Variablen auseinander dividiert sind
\subsubsection{Vereinbarung}
In der Folge nehmen wir an, dass die Variablen auseinander dividiert sind.
\subsection{Pränexnormalform}
\subsubsection{Definition 4.35} 
Eine Formel \(G\) ist in \textbf{Pränexnormalform}, wenn sie von der Form \((Q_1 X_1)\ldots (Q_n X_n)F \) ist, wobei \(Q_i \in \{\forall,\exists\}\), \(\le i \le n\) und \(n \ge 0 \) ist, \(X_1, \ldots , X_n\) Variablen sind und in \(F\) selbst kein Quantor mehr vorkommt. Wir nennen \(F\) auch Matrix von G
\subsubsection{Proposition 4.36} 
Es gibt einen Algorithmus, der einen Satz \(F\) in der Prädikatenlogik in einen semantisch äquivalenten Satz \(F'\) in Pränexnormalform transformiert
\subsubsection{Transformation in Pränexnormalform}
Solange die Formel \(F\) nciht in Pränexnormalform ist, wende eine der folgenden Regeln an:
\begin{align*}
&\frac{\neg(\forall X)F}{(\exists X)\neg F} 
&& \frac{\neg(\exists X)F}{(\forall X)\neg F} \\
&\frac{((QX)F \wedge G)}{(QX)(F \wedge G)} 
&&\frac{(F\wedge (QX)G)}{(QX)(F\wedge G)} \\
&\frac{((QX)F\lor G)}{(QX)(F\lor G)} 
&&\frac{(F\lor (QX)G)}{(QX)(F\lor G)}
\end{align*}
\subsection{Skolem-Normalform}
\subsubsection{Idee}
Wir beseitigen alle existenziellen Quantoren
\subsubsection{Definition 4.37}
Sei \(L = L(R,F,V)\) eine prädikatenlogische Sprache. Sei \(F_S\) eine abzählbar unendliche Menge von Funktionssymbolen, so dass \(F_S \cap F = \emptyset \) und \(F_S\) für jede Stelligkeit abzählbar unendlich viele Funktionszeichen enthält. Die Elemente aus \(F_S\) werden \textbf{Skolem-Funktionssymbole} genannt. Wir betrachten nun die Sprache \(L(R,F\cup F_S, V)\)
\subsubsection{Notation}
0-stellige Skolem-Funktionssymbole werden häufig auch \textbf{Skolem-Konstantensymbole} genannt
\subsubsection{Definition 4.38}
Eine prädikatenlogische Formel ist in \textbf{Skolem-Normalform}, wenn sie von der Form \(\forall X_	) \ldots (\forall X_n)f\) ist, wobei \(n\geq 0\) ist, \(X_1 ,\ldots ,X_n\) Variablen sind und in \(F\) selbst kein Quantor mehr vorkommt
\subsubsection{Transformation in Skolem-Normalform}
Sei \(F\) Formel in Pränexnormalform, deren variablen auseinander dividert sind. Solange \(F\) nicht in Skolem-Normalform ist, wende die folgende Regel an
\begin{align*}
\frac{(\forall X_1) \ldots (\forall X_n)(\exists Y)G}{(\forall X_1)\ldots (\forall X_n)G \{Y\mapsto f(X_1 ,\ldots , X_n)\} }
\end{align*}
\subsubsection{Satz 4.39}
Sei \(F'\) eine Skolem-Normalform des Satzes \(F\). \(F\) ist erfüllbar gdw  \(F'\) ist erfüllbar.\\ \(\to\) Die Tranformation in Skolem-Normalform ist erfüllbarkeitserhaltend
\subsubsection{Beweis Satz 4.39}
\begin{itemize}
	\item Anname: \(F\) in Pränexnormalform; Variablen sind auseinander dividiert
	\item \textbf{Hilfsaussage}: Sei \(F\) ein Satz in Pränexnormalform, in der die Variablen auseinander dividert sind. Sei \(F'\) durch einmalige Anwendung der Ersetzungsregel auf \(F\) entstanden. Dann gilt: \(F\) ist erfüllbar gdw. \(F'\) ist erfüllbar
	\item Beweis Hilfsaussage \(\rightsquigarrow\) Übung
	\item Sei \(E\) die folgende Zusicherung: \(F'\) ist ein Satz in Pränesnormalform, in der alle Variablen auseinander dividiert sind und \(F'\) ist erfüllbar gdw \(F\) ist erfüllbar
	\item mit \(F = F'\) ist \(E\) vor Eintritt in die Schleife erfüllt
	\item Gemäß der Hilfsaussage ist \(E\) eine Schleifeninvariante
	\item Nach \textbf{Satz 3.30} gilt \(E\) dann auch nach Verlassen der Schleife
	\item Die Schleife wird nur verlassen wenn \(F'\) in Skolem-Normalform ist
\end{itemize}
\section{Äquivalenz und Normalenform (2)}
\subsection{Klauselform}
\begin{itemize}
	\item Sei \(F\) ein Satz der Prädikatenlogik und \(H\) eine Skolem-Normalform von \(F\)
	\item \(F\) ist erfüllbar gdw \(F\) erfüllbar
	\item \(H\) ist von der Form \(\forall
	G = (\forall X_1) \ldots (\forall X_n) G\), wobei \(X_1, \ldots ,X_n\) alle in \(H\) vorkommenden Variablen sind
	\item In der Matrix \(G\) kommen keine Quantoren mehr vor
	\item Alle in \(G\) vorkommenden Variablen sind universell quantifiziert
	\item Wir können \(G\) in Klauselform transformieren
	\item Sei \(G'\) eine Formel in Klauselform, die semantisch äquivalent zu \(G\) ist
	\begin{itemize}
		\item \(F\) ist erfüllbar gdw \(\forall G'\) ist erfüllbar
		\item \(F\) ist unerfüllbar gdw \(\forall G'\) ist unerfüllbar
	\end{itemize}
\end{itemize}
\subsection{maschinelles Beweisen mathematischer Sätze}
siehe Folien
\subsection{Unifikation}
\subsubsection{Definition 4.40}
Eine \textbf{Gleichung} ist ein Ausdruck der Form \(s = t\) wobei s und t Terme sind
\subsubsection{Definition 4.41}
Ein \textbf{Unifikationsproblem} \(U\) besteht aus einer Mulitmenge von Gleichungen
\begin{align*}
\{ s_1 = t_1, \ldots , s_n = t_n \}
\end{align*}
und ist die Frage, ob es eine Substitution \(\sigma \) gibt, so dass \(s_i\sigma = t_i\sigma \) für alle \(1\le i \le n\) gilt. \\ Wenn es eine solche Substitution \(\sigma \) gibt, dann
\begin{itemize}
	\item heißt \(U\) lösbar
	\item sind die Terme \(s_i\) und \(t_i, 1 \le i \le n\), simultan unifizierbar
	\item ist \(\sigma\) ein Unifikator für \(U\)
\end{itemize}
\subsection{Allgemeinste Unifikatoren}
\subsubsection{Definition 4.42}
Seien \(\sigma\) und \(\theta\) Substitutionen. \(\sigma\) ist \textbf{allgemeiner als} \(\theta\), symbolisch \(\sigma \ge \theta \), wenn es eine Substitution \(\lambda\) gibt, s dass \(\sigma \lambda = \theta \) gilt
\subsubsection{Definition 4.43}
Substitutionen \(\sigma \) und \(\theta \) sind \textbf{Varianten}, symbolisch \(\sigma \sim \theta\), wenn \(\sigma \ge \theta \) und \(\theta \ge \sigma \) gilt
\subsubsection{Definition 4.44}
Sei \(U\) ein Unifikationsproblem . Eine Substitution \(\sigma \) ist ein \textbf{allgemeinster Unifikator} für \(U\), wenn \(\sigma\) ein Unifikator für \(U\) ist und \(\sigma \ge \theta \) für jeden Unifikator \(\theta \) für \(U\) gilt. \\
Im Englischen werden allgemeinste Unifikatoren Most General Unifier genannt und mit mgu abgekürzt.
\subsubsection{Der Unifikationssatz}
\subsubsection{Satz 4.45}
Wenn \(U\) ein lösbares Unifikationsproblem ist, dann gibt es einen allgemeinsten Unifikator für \(U\)
\subsubsection{Beweis Satz 4.45}
\begin{itemize}
	\item Unifikationsalgorithmus spezifizieren
	\item Terminierung beweisen
	\item Korrektheit beweisen
\end{itemize}

\section{Äquivalenz und Normalform}
\subsection{Beweis Satz 4.45}
\subsubsection{Der Unifikationsalgorithmus}
\subsubsection{Eingabe}
Ein Unifikationsproblem \(U\)
\subsubsection{Ausgabe}
Ein allgemeinster Unifikator \(\theta\) für \(U\), wenn \(U\) lösbar ist, oder \textbf{nicht unifizierbar}, wenn \(U\) keine Lösung besitzt
\subsubsection{Terminierung (76)}
\subsubsection{Korrektheit (79)}
\subsection{Allgemeinste Unifikatoren}
\subsubsection{Korollar 4.46}
Sei \(U\) ein Unifikationsproblem und \(\sigma\) sowie \(\theta\) allgemeinste Unifikatoren für U. Dann gilt \(\sigma \sim \theta \to \) Allgemeinste Unifikatoren sind also bis auf Variantenbildung eindeutig \(\to\) Man spricht deshalb häufig auch von \textbf{dem} mgu zweier Terme

\section{Resolution}
\subsection{Resolutionsregel}
\subsubsection{Definition 4.47}
Gegeben seien die prädikatenlogischen Klauseln
\begin{align*}
fill
\end{align*}
mit \(k,m,n \ge 0\). Wenn \(\{s_i= t_i| 1 \le i \le k\}\) mit einem allgemeinsten Unifikator \(\sigma\) unifizierbar ist, dann nennen wir 
\begin{align*}
	C = \{L_1, \ldots, L_n\}\sigma\}
\end{align*}
eine Resolvente \(C_1\) und \(C_2\) bezüglich \(p(s_1, \ldots , s_k)\) und \(\neg p (t_1, \ldots , t_k)\) \\
fill
\subsubsection{Definition 4.48 Faktorisierungsregel}
Gegeben sei die prädikatenlogische Klausel:
\begin{align*}
 C = fill
\end{align*}
beziehungsweise
\begin{align*}
C = fill
\end{align*}
mit \(k,m \ge 0 \) ... fill
\subsection{Resolutionsableitungen und -widerlegungen}
\subsubsection{Definition 4.49}
Sei \(F = \forall <C_1, \ldots , C_n>\) eine prädikatenlogische Formel in Klauselform, wobei \(C_i, 1 \le i \le n\), Klauseln sind.
\begin{align*}
	fill
\end{align*}
\textbf{Beachte}\\
\begin{itemize}
\item Eine Resolvente kann aus zwei Varianten einer Klausel gebildet werden.
\item fill
\item fill
\item fill
\end{itemize}
Eine Resolvente kann aus zwei Varianten einer Klausel gebildet werden.
\subsubsection{Vollständigkeit des Resolutionsverfahrens - Überblick}
\begin{align*}
\{F_1, \ldots ,F_n\} \vDash F &&\text{Satz 3.17 erweitert}\\
fill
\end{align*}
\subsection{Herbrand-Interpretationen}
\begin{align*}
\text{Seien} F = \{s/0, f/1\}, R = \{p/1, q/1, r/1\}, X,Y \in V\\
&G = (\forall X)(\forall Y)<[p(X), q(X)], [r(f(Y))]>\\
fill
\end{align*}
\subsubsection{Definition 4.58} Sei \(I = (D, \cdot ^I)\) eine Interpretation. Eine zu \(I\) ... fill
\subsubsection{Lemma 4.59} Wenn eine Interpretation \(I\) Modell für einen prädikatenlogischen Satz \(F\) in Skolem-Normalform ist, dann ist auch jede zu \(I\) korrespondierende Herbrand-Interpretation ein Modell für \(F\)\\
\textbf{Folgerung} Die reellen Zahlen lassen sich in der Prädikatenlogik nicht charakterisieren
\begin{itemize}
	\item Angenommen, die reellen Zahlen liesen sich charakterisieren
	\item Dann gibt es Satz f, so dass für alle \(I = (D,\cdot ^I)\) gilt: wenn \(F^I = \top \) dann ist \(D\) überabzählbar
	\item Wähle I mit \(F^I = \top \) 
	\item Sei J korrespondierende Herbrand-Interpretation
	\item fill
\end{itemize}
\subsubsection{Satz 4.60}
Eine prädkatenlogischer Satz F in Skolem-Normalform ist unerfüllbar gdw F wird von jeder Hebrand-Interpretation auf \(\bot\) abgebildet \\
\textbf{Beweis} siehe Folien
\section{Beweis}
\subsection{Beweis Satz 4.60}
siehe Skript
\section{Ende Logik Anfang Automaten}
Skript Baader:\\
https://lat.inf.tu-dresden.de/teaching/ss2014/THEOLOG/\\
THEOLOG2014
B626165

\section{02.06.2016}
\subsection{}
\subsubsection{Beispiel 3.4 (Addition)}
Die Addition natürlicher Zahlen kann durch primitive Rekursion wie folgt definiert werden.:
\begin{align*}
	add(x,0)&= x &&= g(x)\\
	add(x,y+1) &= add(x,y)+1 &&= h(x,add(x,y),y)
\end{align*}
Das heißt also: $add$ entsteht durch primitive Rekursion aus den Funktionen
\begin{itemize}
	\item $g: \mathbb{N} \to \mathbb{N} $\\fill
\end{itemize}
\subsection{Definition}
\subsection{primitiv rekursive Funktion: Beispiel}
\textbf{Multiplikation} erhält man durch primitive Rekursion aus der Addition:
\begin{align*}
	mult(x,0) &= 0&&=null^{(1)}(x)\\
	mult(x,y+1) &= add(x,mult(x,y)) &&= add(\pi_1^{(3)},\pi_2^{(3)})(x,mult(x,y),y)
\end{align*}
\textbf{Exponentiation} erhält man durch primitive Rekursion aus der Multiplikation
\begin{align*}
	exp(x,0) &= 1 &&= s(null^{(1)}(x))\\
	exp(x,y+1) &= mult(x,exp(x,y)) &&= ...\\
\end{align*}
Die Funktion
\begin{align*}
	min1:\mathbb{N} \to \mathbb{N} \text{ mit } x \mapsto x-1:= \begin{cases}
  x-1 &x>0\\
 0 &x = 0
\end{cases}
\end{align*}
ist ebenfalls primitiv rekursiv:
\begin{align*}
	min1(0) &= 0 &&= null^{(0)}()\\
	min1(y+1) &= y &&= ...
\end{align*}
\subsection{Besipliel 3.7}
Aus den bisher betrachteten Funktionen erhält man damit die Funktion
\begin{align*}
	c: \mathbb{N}^2 \to \mathbb{N} \text{ mit } (x,y) \mapsto 2^x \cdot (2y+1)-1
\end{align*}
durch Komposition, d.h. c ist primitiv rekursiv (diese Funktion ist eine Bijektion von $\mathbb{N}^2 \to \mathbb{N}$).
Da c eine Bijektion ist, gibt es die Umkehrfunktionen $c_0$ und $c_1$ mit der Eigenschaft:
\begin{align*}
	&c_0(c(x,y))= x \text{ und } c_1(c(x,y)) = y\\
	&c(c_0(z), c_1(z)) = z
\end{align*}
Diese ergeben sich im Prinzip aus dem Beweis von Lemma 3.8:
\begin{align*}
	c_0(z) &= ... \\
	...
\end{align*}
\subsection{Lemma 3.9}
Die Funktionen sign: $\mathbb{N} \to \mathbb{N} $ und $\overline{sign}: \mathbb{N} \to \mathbb{N}$ mit:
\begin{align*}
&sign(x) = \begin{cases} 0 &x = 0\\
1 & x > 0 \end{cases}
\end{align*}
\subsection{Fallunterscheidung}
Es seien $g_1, g_2, h : \mathbb{N}^n \to \mathbb{N} $ gegeben. Die Funktion $f:\mathbb{N}^n \to \mathbb{N} $ entsteht daraus durch Fallunterscheidung, falls für alle $x \in \mathbb{N}^n$ gilt:
\begin{align*}
	&f(x) = \begin{cases} g_1(x) &\text{falls } h(x) = 0\\
	g_2(x) &\text{falls } h(x) > 0
	\end{cases}
\end{align*}
\subsection{Lemma 3.11}
sind $g_1, g_2, h$ primitiv rekursiv, so auch $f$.
\subsection{Definition 3.12: bechränkte Minimalisierung}
Es sei $n \geq 0 $. Die Funktion $ f: \mathbb{N}^{n+1} \to \mathbb{N}$ entsteht aus $g: \mathbb{N}^{n+1} \to \mathbb{N}$ durch beschränkte Minimalisierung, falls gilt:
\begin{align*}
	f(x,y) = \begin{cases} j &\text{falls } j = min\{i\leq y | g(x,i) = 0\} \text{ existiert }\\
	y+1 &\text{sonst}
	\end{cases}
\end{align*}
Wir schreiben dann $f = \overline \mu g$.
\subsection{Lemma 3.13}
Ist $g$ primitiv rekursiv, so auch $\overline \mu g$.

\section{•}
Es sei P ein LOOP - Programm für $f: \mathbb{N}' \to \mathbb{N}$
Es sei l der maximale Index der in P vorkommenden Variablen und $ K = max\{r,l\}$. wir zeigen durch Induktion über den Aufbau von LOOP-Programmen, dass die folgende Funktion $g_p : \mathbb{N}\to \mathbb{N}$ primitiv rekursiv ist:
\begin{align*}
	z \to_{\text{kodieren}} a_0, \ldots , a_k \to_P b_0, \ldots, b_k \to_{\text{dekodieren}} g_{P^{(z)}}
\end{align*}

... fill ... \\

Um alle berechnbaren Funktionen zu erhalten, muss man
\begin{itemize}
	\item die primitiv rekursiven Funktionen um eine weitere Operation, die unbeschränkte Minimalisierung erwetiern;
	\item die LOOP-Programme muss an um eine While-Schleife erweitern ...
\end{itemize}
Beachte: Der $\mu$-Operator sucht im Prinzip nach dem kleinsten y, so dass $g(\underline{x},y) = 0$ ist. Dabei müssen aber alle vorherigen Werte g...
\subsection{Definition 4.1}
Die funktion $f: \mathbb{N}^n \to \mathbb{N}$ entsteht aus $g:\mathbb{N}^{n+1} \to \mathbb{N}$ durch unbeschränkte Minimalisierung ...
\subsection{Beispiel 4.2}
\begin{align*}
	&g_1(x,y) = \begin{cases} 
	x-y &\text{ falls } x \ge y\\
	\text{undefiniert} &\text{ falls } x < y \end{cases}\\
	&g_2(x,y) = \begin{cases} 
	y-x &\text{ falls } x \ge y\\
	\text{undefiniert} &\text{ falls } x < y \end{cases}\\
	&g_3(x,y) = x+y =\begin{cases} 
	0 &\text{ falls } x =0\\
	\text{undefiniert} &\text{ sonst} \end{cases}
\end{align*}
Durch Anwendung ...
\subsection{Definition 4.3 Klasse der $\mu$-rekursiven Funktionen}
fill
\subsection{Definition 4.4 Syntax von WHILE-Programmen}
Die Syntax von WHILE-Programmen enthält alle Konstrukte in der Syntax von LOOP-Programmen und zusätzlich
\begin{itemize}
	\item[4.] Falls P ein WHILE-Programm ist und $i\ge 0$, so ist auch 
	\begin{align*}
		\text{WHILE } x_i \neq 0
	\end{align*}
\end{itemize}
fill\\
\textbf{Beacte}: Man könnte bei der Definition der While-Programme auf das LOOP-Konstrukt verzichten, da es durch WHILE simulierbar ist: 
\begin{lstlisting}
LOOP x DO P END
\end{lstlisting}
kann simuliert werden durch:
\begin{lstlisting}
y = x + 0 
WHILE ...
\end{lstlisting}
fill
\subsection{Definition 4.5}
Die (partielle) Funktion $f:\mathbb{N}^2 \to \mathbb{N}$ mit:
\begin{align*}
	&(x,y) \mapsto \begin{cases} x-y &\text{ falls } x\ge y\\
	\text{undefiniert} &\text{ sonst }\end{cases}
\end{align*}
ist WHILE-berechenbar durch das folgende Programm:
\begin{lstlisting}
WHILE x2 != 0 DO
	x3 = x1;
	WHILE x3 != 0 DO
		x1 = x1 - 1
		x2 = x2 - 1
		x3 = 0
	END
END
x0 = x1;
\end{lstlisting}
\subsection{Satz 4.7}
Die Klasse der $\mu$  ... fill ...
\subsection{Beweis Satz 4.7}

\section{}
fill
\subsection{Darstellung von Zahlen auf Touringmaschinen}
fill\par
Ändern dieses Symbols zu $a_j$:\par 
Der neue wert von $x_3$ ist
\begin{align*}
	(j_r, \ldots, j_2, j)_b = div((j_r, \ldots, j_2, j_1)_b, b)\cdot b+j
\end{align*}
Das WHILE-Programm, welches die gegebene DTM simuliert, arbeitet wie folgt:
\begin{itemize}
	\item Aus der Eingabe wird die Kodierung der Startkonfiguration der DTM in den Variablen ... fill
	\item fill
	\item fill
\end{itemize}
Insgesamt haben wir also gezeigt:
\subsection{Theorem 4.10}
Die folgenden Klassen von Funktionen ... fill
\subsection{Universelle Turing-maschinen und unentscheidbare Probleme}
Wir werden heir zeigen, dass es Relationen(Problee) gibt, die nicht Turing-entscheidbar sind, d.h. ihre charakteristische Funktion ist nicht Turing-berechenbar. Mit der Churchschen These ... fill
\subsubsection{Konventionen}
\begin{itemize}
	\item Arbeitsalphabete der betrachteten Turingmaschinen sind Teilmengen von $\{a_1, a_2, a_3, \ldots\}$. wobei $a_1 = a, a_2 = b, a_3 = \not b$
	\item Zustandsmengen der etrachteten Turingmaschinen sind Teilmengen von $\{q_1, q_2, \ldots\}$ ... fill
	\end{itemize}
\subsection{Definition 5.1 - Kodierung einer Turingmaschine}
Es sei $A = (Q, \Sigma, \Gamma, q_1, \Delta, F)$ eine Turingmaschine die (o.B.d.A.) die obigen Konventionen erfüllt.
\begin{itemize}
	\item Eine Transition
	\begin{align*}
		t = (q_i, a_j, a_{j'}, l|r|n, q_{i'})
	\end{align*}
	wird kodiert durch:
	\begin{align*}
		code(t) = a^iba^jba^{j'}ba|aa|aaaba^{i'}bb
	\end{align*}
	\item fill
\end{itemize}
\subsection{Bemerkung 5.2}
Es sei $A$ eine TM und $w\in \Sigma^*$. Für
\begin{align*}
	x = code(A)w
\end{align*}
gilt das folgende:
\begin{itemize}
	\item $w$ beginnt genau nach dem zweiten Block bbb
	\item $w$ kann also aus $x$ eindeutig wieder herausgelesen werden
\end{itemize}
Es gibt eine DTM $A_{CODE}$, welche \ldots fill
\subsection{Satz 5.3 Turing}
Es gibt eine unverselle DTM $U$ über $\Sigma$, d.h. eine DTM it der folgenden Eigenschaft: Für alle DTM $A$ und alle $w \in \Sigma^*$gilt:
\begin{align*}
	&U\text{ akzeptiert } code(A)w &&\text{gdw ... fill}
\end{align*}
\subsubsection{Konfigurationskodierung:}
fill
\subsubsection{Arbeitsweise von U}
fill
\subsection{Satz 5.4}
Die Relation
\begin{align*}
	&UNIV := code(A)w \in \Sigma^* | A \text{ is DTM über }\Sigma \text{ ... fill ...}
\end{align*}
ist partiell entscheidbar aber unentscheidbar.
\subsubsection{Beweis}
fill
\section{}
\subsection{Satz 5.5}
$L_1 \subset L_0$\\
\subsubsection{Beweis}
siehe Folien S. 43
\subsection{Satz 5.6}
Das Wortproblem für DTM (und damit auch für $L_0$ ist unentscheidbar, d.h. es gibt kein Berechnungsverfahren, das zu jeder gegebenen DTM A und jedem Eingabewort w entscheidet, ob A das Wort w akzeptiert.
\subsection{Beweis}
Wenn das Wortproblem für DTM entscheibar wäre, so wäre auch UNIV entscheidbar (ist es aber nicht). Um zu entsscheiden ob $code(A)w \in \text{UNIV}$ ist, müsste man ja nur das Entscheidungsverfahren für das Wortproblem feststellen lassen, ob A das Wort w akzeptiert.
\subsection{Satz 5.7}
Das Halteproblem für DTM ist unentscheidbar, d.h. es gibt kein Berechnungsverfahren das zu jeder gegebenen DTM $\hat A$ entscheidet, ob $\hat A$ beginnend mit leerem Eingabeband terminiert.
\subsubsection{Beweis}
Wäre das Halteproblem entscheidbar, so auch das Wortproblem. \par 
Um zu gegebner TM $A$ und gegebenem Wort $w$ zu entscheiden, ob $A$ das Wort $w$ akzeptiert, könnte man dann nämlich wie folgt vorgehen:\par 
\begin{itemize}
	\item Bei leerem Band schreibt $\hat A$ zunächst $w$ auf das Band.
	\item Danach verhält sich $\hat A$ wie $A$
	\item Stoppt $A$ mit akzeptierender Stoppkonfiguration, so stoppt auch $\hat A$. Hält $A$ mit nichtakzeptierender Stoppkonfiguration, so geht $\hat A$ in eine Endlosschleife.
\end{itemize}
Damit gilt:
\begin{align*}
	&\hat A \text{ hält mit leerem Eingabeband} &&\text{\underline{gdw.} } A \text{ akzeptiert }w
\end{align*}
Mit dem Entscheidungsverfahren für das Halteproblem (angewandt auf $\hat A$) könnte man also das Wortproblem (Ist $w$ in $L(A)$?) entscheiden.
\subsection{Satz 5.8}
Das Leerheitsproblem für DTM (und damit auch für $L_0$) ist unentscheidbar, d.h. es gibt kein Berechnungsverfahren, das bei gegebener DTM $\hat A$ entscheidet, ob es eine Eingabe $w$ gibt, auf der $\hat A$ terminiert.
\subsubsection{Beweis}
Wäre das Leerheitsproblem entscheidbar, so auch das Halteproblem.\par
Um bei gegebener DTM $A$ zu entscheiden, ob $A$ auf leerer Engabe hält, konstruiert man die DTM $\hat A$ wie folt:
\begin{itemize}
	\item $\hat A$ löscht seine Eingabe
	\item Danach verhält sich $\hat A$ wie $A$
	\item Stoppt die Berechnung, so geht $\hat A$ in eine akzeptierende Stoppkonfiguration
\end{itemize}
Offenbar gibt es eine Eingabe, für die $\hat A$ hält \underline{gdw.} $A$ auf leerem Eingabeband hält.
\subsection{Satz 5.9}
Das Äquivalenzproblem für DTM (und damit auch für $L_0$) ist unentscheidbar.
\subsubsection{Beweis}
Offenbar kann man leicht eine DTM $\hat A$ konstruieren mit $L(\hat A) = \emptyset $. \par 
Wäre das Äquivalenzproblem
\begin{align*}
	L(A_1) = L(A_2)
\end{align*}
entscheidbar, so könnte man durch den Test
\begin{align*}
	L(A) = L(\hat A)
\end{align*}
das Leerheitsproblem für A entscheiden.
\subsection{Satz 5.10}
$L_0$ ist nicht unter Komplement abgeschlossen.
\subsubsection{Beweis}
Wir wissen von der in Satz 5.4 eingeführten Sprache UNIV:
\begin{itemize}
	\item UNIV ist partiell entscheidbar, d.h. gehört zu $L_0$
	\item UNIV ist nicht entscheidbar
\end{itemize}
Wäre $\overline{UNIV} \in L_0$, d.h. partiell entscheidbar, so würde aber mit Satz 2.4 (Teil 4) folgen, dass UNIV entscheidbar ist. \par
\subsubsection{Unentscheidbarkeit zeigen}
Wie kann man Unentscheidbakeit eines Problems (formal: einer Relation) zeigen?
\begin{itemize}
	\item[1] Durch ein Diagonalisierungsargument wie im Beweis von Satz 5.4
	\item[2] Das in den Beweisen der Sätze 5.6 bis 5.9 gewählte Vorgehen nennt man Reduktion:
	\begin{itemize}
		\item Ein Problem $P_1$ (z.B. halteproblem) wird auf ein Problem $P_2$ (z.B. Äquivalenzproblem) reduziert.
		\item Wäre daher $P_2$ entscheidbar, so auch $P_1$
		\item Weiss man bereits, dass $P_1$ unentscheidbar ist, so folgt daher, dass auch $P_2$ unentscheidbar ist.
	\end{itemize}
\end{itemize}
Formaler betrachten wir (o.B.d.A.) einstellige Relationen $R \subseteq \Sigma^*$
\subsection{Definition 5.11 (Reduktion)}
\begin{itemize}
	\item[1)] Eine Reduktion von $R_1 \subseteq \Sigma^*$ auf $R_2 \subseteq \Sigma^*$ ist eine berechenbare Funktion
	\begin{align*}
		f: \Sigma^* \to \Sigma^*
	\end{align*}
	für die gilt:
	\begin{align*}
		w \in R_1 \text{ \underline{gdw.} } f(w) \in R_2
	\end{align*}
	\item[2)] Wir schreiben
	\begin{align*}
		&R_1 \leq_m R_2 &&R_1 \text{wird auf }R_2\text{ reduziert}
	\end{align*}
	falls es eine Reduktion von $R_1$ nach $R_2$ gibt.
\end{itemize}
\subsection{Lemma 5.12}
\begin{itemize}
	\item[1)] $R_1 \leq_m R_2$ und $R_2$ entscheidbar $\Rightarrow R_1$ entscheidbar
	\item[2)] $R_1 \leq_m R_2$ und $R_1$ unentscheidbar $\Rightarrow R_2$ unentscheidbar
\end{itemize}
\subsubsection{Beweis}
\begin{itemize}
	\item[1)] Um $w\in R_1$ zu entscheiden
	\begin{itemize}
		\item berechnet man $f(w)$ und
		\item entscheidet $f(w) in R_2$
	\end{itemize}
	\item[2)] Folgt unmittelbar aus 1)
\end{itemize}
Mit Hilfe einer Reduktion des Halteproblems kann man zeigen: Jede nichttriviale semantische Eigenschaft von Programmen (DTM) ist unentscheidbarl
\begin{itemize}
	\item Semantisch: heißt hier: Die Eigenschaft hängt nicht von der syntaktischen Form des Programms, sondern nur von der berechneten Funktion ab.
	\item Nichttrivial: Es gibt berechenbare Funktionen, die sie erfüllen, aber nicht alle berechenbaren Funktionen erfüllen sie.
\end{itemize}
Beispiele für solche Eigenschaften:
\begin{itemize}
	\item die berechnete Funktion ist total, d.h. die DTM hält für jede Eingabe.
	\item die berechnete Funktion ist bei Eingabe $\epsilon$ definiert (Halteproblem).
	\item die berechnete Funktion ist die Nullfuntion, d.h. der Funktionswert ist für jede Eingabe gleich 0.
	\item die berechnete Funktion liefert bei Eingabe $\epsilon$ den Wert 0.
	\item \ldots
\end{itemize}
\subsection{Satz 5.13 (Satz von Rice)}
Es sei E eine Eigenschaft partiell berechenbarer Funktionen $f: \Sigma^*  \to \Sigma^* $ so dass gilt:
\begin{align*}
	\emptyset \subset \{f:\Sigma^* \to \Sigma^* | f \text{ erfüllt } E\} \subset \{f: \Sigma^* \to \Sigma^* | f \text{  ist partiell berechenbar}\}
\end{align*}
dann ist
\begin{align*}
	L(E) := \{code(A) | \text{die von }A\text{ berechnete Funktion }f: \Sigma^* \to \Sigma^* \text{ erfüllt } E\}
\end{align*}
unentscheidbar.
\subsubsection{Beweis}
Angenommen $L(E)$ ist entscheidbar\par
Wir zeigen, dass man dann auch ein Entscheidungsverfahren für das Halteproblem erhält (Widerspruch zu Satz 5.7).\par 
Mit $f_u$ bezeichnen wir die überall undefinierte Funktion, welche offenbar partiell berechenbar ist. O.B.d.A. erfülle $f_u$ die Eigenschaft $E$. \par 
Sonst könnte man statt $E$ die Eigenschaft $\overline{E}$: "$f$ erfüllt $E$ nicht" betrachten. mit $L(E)$ ist auch $L(\overline{E})= \overline{L(E)}$ entscheidbar. \par 
Da nicht alle partiell berechenbaren Funktionen $E$ erfüllen, gibt es eine partiell berechenbare funktion $g$, welche $E$ nicht erfüllt.\par 
Es sei nun $A_g$ eine DTM für $g$ und $A_u$ eine für $f_u$. Wir konstruieren nun eine DTM $A'$, welche eine Funktion $f:\Sigma^* \to \Sigma^*$ berechnet mit:
\begin{align*}
	&w = code(a) \text{ für eine DTM , die auf leerer Eingabe terminiert}\\
	&\text{gdw } f(w) \notin L(E) &&(*)
\end{align*}
Wäre daher $L(E)$ entscheidbar, so auch das Halteproblem.
\\

\textbf{Konstruktion von $A'$:}\par Die DTM $A'$ testet bei Eingabe $w$ zunächst, ob $w$ Kodierung einer DTM ist.
\begin{itemize}
	\item Falls nein, so gibt $A' code(A_u) \in L(E)$ aus
	\item Falls ja, so ist $w = code(A) $ für eine DTM $A$. Die DTM $A'$ gibt dann $code(A'')$ aus, wobei $A''$ noch geeignet zu definieren ist:
	\begin{align*}
		code(A'') \notin L(E) \text{  \underline{gdw}. } A \text{ hält auf leerer Eingabe}
	\end{align*}
\end{itemize}
\textbf{Definition von $A''$:}\par 
\begin{itemize}
	\item $A''$ ignoriert zunächst die Eingabe $x$ und simuliert das Verhalten von $A$ auf dem leeren Eingabeband.
	\item Im Anschluss (d.h. falls $A$ auf leerem Eingabeband terminiert) verhält sich $A''$ wie $A_z$ bei Eingabe $x$.
\end{itemize}
Damit gilt für $A''$ offenbar:
\begin{itemize}
	\item Terminiert $A$ auf leerer Eingabe nicht, so berechnet $A''$ die Funktion $f_u$, d.h. $code(A'') \in L(E)$, da $f_u$ $E$ erfüllt.
	\item Terminiert $A$ auf leerer Eingabe, so berechnet $A''$ die Funktion $g$, d.h. $code(A'')\notin L(E)$, da $g$ $E$ nicht erfüllt.
\end{itemize}
Insgesamt haben wir also gezeigt, dass die von $A'$ berechnete Funktion $f$ die Bedingung (*) erfüllt, das Halteproblem also auf das Problem, $L(E)$ zu entscheiden, reduziert. \par 
Da das Halteproblem unentscheidbar ist, folgt die Unentscheidbarkeit von $L(E)$.
\section{}
\subsection{Definition 6.1 (Postsches Korrespondenzproblem)}
Eine Instanz es Postschen Korrespondenzproblems (PKP) ist gegeben durch eine endliche Folge
\begin{align*}
	P = (x_1,y_1),\ldots,(x_k, y_k)
\end{align*}
von Wortpaaren mit $x_i, y_i \in \Sigma^+$ für ein endliches Alphabet $\Sigma$.\\
Eine Lösung des Problems ist eine Indexfolge $i_1, \ldots, i_m$ mit \begin{itemize}
	\item $m>0$ und
	\item $i_j \in \{1, \ldots, k\}$,
\end{itemize}
so dass gilt: $x_{i_1} \ldots x_{i_m} = y_{i_1} \ldots y_{i_m}$.\par
\subsubsection{Beispiel}
siehe Skript 48
\subsubsection{Bemerkung}
Um die Unentscheidbarkeit des PKP zu zeigen, führen wir zunächst ein Zwischenproblem ein, das modifizierte PKP (MPKP):\par
Hier muss für die Lösung zusätzlich $i_1 = 1$ gelten, d.h. das Wortpaar, mit dem man beginnen muss ist festgelegt.
\subsection{Lemma 6.3}
Das MPKP kann auf das PKP reduziert werden.
\subsubsection{Beweis}
Siehe Vorlesung 49\\
$\to$ Das MPKP P hat eine Lösung \underline{gdw}. Das PKP f(P) hat eine Lösung
\subsubsection{Beispiel}
$P = (a, aaa),(aab,b)$ ist als MPKP lösbar mit Lösung 1,2.
\begin{align*}
	f(P) = (\#a\#,\#a\#a\#a),(a\#,\#a\#a\#a),(a\#a\#b\#, \#b), (\$,\#\$)
\end{align*}
Die Lösung 1, 2 von $P$ liefert die Lösung 0,2,3 von $f(P)$:
\begin{align*}
	&\#a\#|a\#a\#b\#|\$\\
	&\#a\#a\#a|\#b|\#\$
\end{align*}
Offenbar muss jede Lösung von $f(P) $ mit 0 beginnen.\\
Wäre daher das PKP entscheidbar, so auch das MPKP. Um die Unentscheidbarkeits des PKP zu zeigen, genügt es also zu zeigen, dass MPKP unentscheidbar ist.
\subsection{Lemma 6.4}
Das Halteproblem kann auf das MPKP reduziert werden.
\subsubsection{Beweis}
siehe Vorlesung 50 ff.
\subsection{Satz 6.5}
Das PKP ist unentscheidbar.\\
Wir verwenden dieses Resultat um Unentscheidbarkeit von Porblemen für kontextfreie und kontextsensitive Sprachen nachzuweisen. Wir zeigen zunächst:
\subsection{Lemma 6.6}
Es ist nicht entscheidbar, ob für kontextfreie Grammatiken $G_1, G_2$ gilt:
\begin{align*}
	L(G_1)\cap L(G_2) \not = \emptyset
\end{align*}
\subsection{Beweis}
siehe Vorlesung 52.

